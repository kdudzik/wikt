\label{chap:impl}
W~ostatnim rozdziale szczegółowo przedstawiony została implementacja aplikacji. Opisano użyte technologie i~metodologię, a~szczególną uwagę poświęcono problemom, które powstały podczas procesu tworzenia programu. Pierwsza sekcja zawiera opis środowiska, w~którym osadzona jest aplikacja, natomiast kolejne dwie skupiają się na dwóch logicznie wyodrębionych częściach projektu: uproszczonym formularzu edycyjnym oraz automatyzacji tworzenia haseł. W~ostatniej części rozdziału przedstawiono przebieg wdrożenia aplikacji w~polskim Wikisłowniku i~możliwości dalszego rozwoju.

Niniejszy rozdział zawiera odniesienia do plików źródłowych składających się na aplikację oraz pomocniczych. Wszystkie te pliki znajdują się na dołączonej do pracy płycie~CD w~katalogu \kod|src|.

\section{Wprowadzenie}
Oprogramowanie MediaWiki zostało napisane w~języku PHP (\emph{PHP Hypertext Preprocessor}) i~jest wysoce konfigurowalne za pomocą tzw. rozszerzeń, dodających kolejne funkcje -- przykładowo: obsługę przypisów, dodatkowe strony specjalne czy nowe funkcje parsera~\cite{mw:extensions}. W~projektach Fundacji obsługa rozszerzeń jest kontrolowana przez Fundację. Poszczególne projekty mogą składać prośby o~włączenie określonego rozszerzenia, decyzję podejmują zaś główni programiści Fundacji. Teoretycznie można rozważać utworzenie aplikacji dla Wikisłownika jako rozszerzenia w~PHP. Opcja ta została jednak odrzucona we wstępnej fazie projektu -- stworzenie rozszerzenia wymagałoby nieporównanie więcej formalności niż aplikacja kliencka, przede wszystkim jednak jego funkcjonalność byłaby znacznie ograniczona: poza polskim Wikisłownikiem żaden inny projekt nie mógłby z~niego skorzystać, na pewno nie zostałby więc włączony do głównej wersji MediaWiki.

\subsection{JavaScript w~Wikisłowniku}
Podobnie jak w~wielu innych przypadkach w~obrębie projektów Wikimedia jako metodę dostosowania silnika MediaWiki do szczególnych potrzeb wybrano zatem aplikację napisaną w~języku JavaScript. Konieczne jest zatem przedstawienie sposobu obsługi skryptów na stronach tych witryn. Pliki JavaScript ładowane są z~wielu różnych źródeł -- hierarchia w~nieco uproszczonej postaci jest następująca~\cite{de:js}:
\begin{enumerate}
	\item skrypty systemowe oprogramowania MediaWiki, wspólne dla wszystkich projektów oraz charakterystyczne dla danego projektu ze względu na ładowane rozszerzenia,
	\item skrypt zapisany na poziomie danego projektu jako strona \kod|MediaWiki:Common.js| -- dostęp do niego mają lokalni administratorzy,
	\item skrypt zapisany na poziomie danego projektu dla wybranej przez użytkownika skórki (domyślną jest \emph{Vector}, poprzednią był \emph{Monobook}) jako strona, np. \kod|MediaWiki:Vector.js| -- dostęp do niego mają lokalni administratorzy,
	\item tzw. gadżety, czyli dodatkowe skrypty rozszerzające funkcjonalność, możliwe do włączenia w~preferencjach użytkownika -- także one edytowane i~wybierane są przez administratorów,
	\item skrypt zapisany na stronie danego użytkownika, np. \kod|User:Sokrates/common.js| -- na tym poziomie możliwe jest dostosowywanie skryptów do swoich potrzeb przez każdego użytkownika,
	\item skrypt zapisany na stronie danego użytkownika dla wybranej skórki, np. dla skórki \emph{Vector} -- \kod|User:Sokrates/vector.js|.
\end{enumerate}
Jak widać, możliwości dołączania dodatkowych skryptów są elastyczne i~dostępne na różnych poziomach dla różnych użytkowników. Decyzja o~włączeniu skryptów dla wszystkich użytkowników danego projektu należy do jego administratorów (nie licząc wspólnych skryptów narzuconych przez Fundację), natomiast każdy użytkownik poprzez edycję specjalnej strony może uruchamiać różne skrypty na swoje potrzeby, nie będąc zmuszonym do korzystania z~dodatków do przeglądarek, takich jak Greasemonkey. W~ten sposób ułatwiony jest proces powstawania i~testowania nowych skryptów: osoby chcące przetestować nowy skrypt mogą na swojej stronie JS dołączyć go do swojej. Jeśli administratorzy uznają skrypt za wartościowy, mogą go dodać do zbioru gadżetów (wtedy każdy użytkownik ma możliwość włączenia skryptu bez konieczności edycji plików JS) lub do ogólnego pliku \kod|MediaWiki:Common.js|.

\paragraph{MediaWiki 1.17}
Projekty Fundacji od czerwca 2011~roku używają wersji MediaWiki~1.17. Wersja ta wprowadziła kilka istotnych zmian, spośród których najważniejszą było wprowadzenie modułu \kod|ResourceLoader|, zmieniającego system ładowania dodatkowych plików, przede wszystkim skryptów i~arkuszy stylów~\cite{mw:117}. Wszystkie potrzebne pliki są łączone w~jeden i~dodatkowo kompresowane, dodatkowo poprawiono też obsługę pamięci podręcznej po stronie klienta. Do tej pory poszczególne pliki JS i~CSS przesyłane były statycznie w~wielu żądaniach HTTP, co mogło powodować problemy z~ich synchronizacją, a~przede wszystkim zwiększało obciążenie sieci. Aktualizacja software'u projektów Fundacji spowodowała konieczność aktualizacji większości używanych w~nich skryptów i~zaangażowała większość aktywnych uczestników zaznajomionych z~technikaliami~\cite{mw:migration}.

Od wersji~1.16 do MediaWiki dołączana jest biblioteka programistyczna jQuery, a~w~najnowszym wydaniu zaktualizowano ją do wersji 1.4.2~\cite{mw:jquery}. Jest to jedna z~najczęściej używanych bibliotek dla JavaScript, w~bardzo dużym stopniu usprawniająca programowanie w~tym języku. Kod pisany za jej pomocą jest o~wiele czytelniejszy i~prostszy, biblioteka pozwala też wyeliminować wiele problemów związanych z~nieprawidłową obsługą JavaScript w~niektórych przeglądarkach~\cite{jquery:action}~\cite{jquery:doc}.

\subsection{Środowisko programistyczne}
Programowanie w~JavaScript wymaga użycia innych metod niż tworzenie aplikacji desktopowych. Do tworzenia edytora dla Wikisłownika użyto m.in. następujących aplikacji:

\paragraph{Geany}
Lekkie zintegrowane środowisko programistyczne (IDE)~\cite{geany}. W~początkowej fazie projektu używane było środowisko Eclipse z~dodatkowymi wtyczkami -- okazało się jednak, że obsługa JavaScript nie jest w~nim na tyle wygodna, aby konieczne było wykorzystywanie tak rozbudowanego edytora.
\paragraph{Przeglądarki internetowe}
Aplikacja została przetestowana w~przeglądarkach Firefox $\geq$~4, Chrome $\geq$~10, Opera $\geq$~10 i~Internet Explorer $\geq$~7, pod systemami operacyjnymi Linux i~Windows. Wyeliminowano wszystkie błędy, które zostały odkryte w~czasie testów. Do implementacji używane były przeglądarki Google Chrome (i~jej wbudowane narzędzia deweloperskie) oraz Firefox z~dodatkiem Firebug, ułatwiającym debugowanie aplikacji~\cite{firebug}. Prawidłowe działanie aplikacji pod maksymalną możliwą liczbą dostępnych przeglądarek jest kluczowe ze względu na jej charakter -- edycja jest dostępna dla każdego użytkownika. Nie testowano jednak edytora w~starszych wersjach tych programów ze względu na ich znikome rozpowszechnienie i~niewspółmierny koszt takich testów w~stosunku do spodziewanych korzyści.
\paragraph{Git}
Systemem kontroli wersji używanym w~projekcie był Git. Dzięki niemu możliwe było uniknięcie jakichkolwiek problemów związanych z~zarządzaniem wersjami. Dla celów bezpieczeństwa kod był na bieżąco wysyłany do zdalnego repozytorium założonym w~serwisie GitHub~\cite{github}. Kontroli wersji podlegała również niniejsza praca i~jej kod źródłowy w~systemie \LaTeX. Historia zmian aplikacji i~pracy jest dostępna do wglądu na serwerach GitHub~\cite{github:wikt}.
\paragraph{The Regex Coach}
W~aplikacji duże znaczenie odgrywają wyrażenia regularne, wykorzystywane podczas parsowania wikitekstu. The Regex Coach jest programem ułatwiającym konstruowanie poprawnych wyrażeń~\cite{regexcoach}.
\spacer

\subsection{Dobre praktyki}
Nowy edytor został napisany za pomocą biblioteki jQuery, co ułatwia utrzymanie dobrej struktury. Kod podzielono na moduły funkcjonalne, co częściowo stanowi odpowiednik klasycznego paradygmatu obiektowego, często stosowany w~przypadku JavaScript. Język ten umożliwia pisanie aplikacji przy zachowaniu wielu różnych paradygmatów. W~przypadku opisywanej aplikacji zdecydowano się na wspomniany podział na moduły, będący pewnym kompromisem między paradygmatem funkcyjnym i~obiektowym. Moduły zaimplementowane są jako obiekty, których elementami są funkcje odpowiedzialne za operacje działające w~podobnym zakresie. Przykładowo parser wikitekstu jest modułem o~następującej strukturze:
\begin{lstlisting}
var EParser = {
	getSections : function (code) {
		...
	},
	getSectionFromTitle : function (str) {
		...
	},
	getTitleFromCode : function (code) {
		...
	},
	...
};
\end{lstlisting}
Podział na moduły ułatwia zachowanie kilku spośród licznych praktyk zalecanych przy programowaniu w~JavaScript. Istnieje kilka narzędzi, które w~automatyczny sposób badają jakość kodu w~tym języku, pomagając znaleźć potencjalne błędy i~uniknąć kolejnych. Podczas procesu implementacji stale korzystano z~trzech z~nich: JSHint~\cite{jshint:doc}, JavaScriptLint~\cite{javascriptlint:doc}, a~przede wszystkim JSLint~\cite{jslint:doc}. Narzędzia te nie są do końca kompatybilne ze sobą nawzajem, dlatego za cel obrano całkowity brak ostrzeżeń generowanych przez JSLint. W~ten sposób udało się utrzymać m.in. następujące elementy:
\begin{itemize}
	\item kontrola nad zmiennymi globalnymi (w~przeciwieństwie do innych języków, np. PHP, domyślna deklaracja zmiennej bez słowa kluczowego \kod|var| powoduje umieszczenie jej w~zakresie globalnym),
	\item kończenie poleceń średnikiem (ich brak może prowadzić do błędów bardzo trudnych do wykrycia),
	\item odpowiednie tworzenie bloków kodu,
	\item sprawdzanie \kod|if (object.hasOwnProperty(name))| wewnątrz pętli \kod|for name in object| (z~powodu rozszerzalności prototypów funkcji brak takiego obostrzenia prowadzi do błędów),
	\item prawidłowe używanie operatorów takich jak \kod|===|, \kod|!==|,
	\item prawidłowe używanie konstruktorów,
	\item spójne wcięcia i~używanie nawiasów.
\end{itemize}

% jeden plik, make, jslint

% http://www.mediawiki.org/wiki/Coding_conventions

\section{Formularz edycyjny}
\label{sec:impl-form}

% UI
% parser

\section{Automatyzacja edycji hasła}
% API, JSONP

\label{sec:impl-auto}

\section{Wdrożenie i~dalszy rozwój}

%licencja
